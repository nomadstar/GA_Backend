\section{Arquitectura del sistema Quickshift}

Este capítulo detalla la arquitectura técnica implementada en \texttt{quickshift}, motor de cálculo desarrollado en Rust. La descripción se basa estrictamente en el código de producción disponible en \texttt{src/}, documentando estructuras, funciones y flujos tal como están implementados.

\subsection{Arquitectura de capas}

El sistema sigue una arquitectura de pipeline implementada en los directorios \texttt{src/excel/}, \texttt{src/algorithm/} y \texttt{src/api\_json/}. El flujo de datos es unidireccional y está orquestado por \texttt{src/algorithm/ruta.rs} mediante la función \texttt{ejecutar\_ruta\_critica\_with\_params}.

\begin{center}
    \begin{tikzpicture}[
      node distance=1.7cm,
      every node/.style={font=\small},
      box/.style={rectangle, draw, rounded corners, align=center, fill=gray!10, minimum width=3.0cm, minimum height=1.1cm},
      arrow/.style={->, thick},
    ]
    
    \node[box, fill=blue!10] (ingesta) {Capa de Ingesta \\ \texttt{excel/} \\
    Lectura Excel \\ Normalización \\ Mapeo};
    
    \node[box, fill=green!10, right=1.0cm of ingesta] (algoritmia) {Capa de Algoritmia \\ \texttt{algorithm/} \\
    PERT \\ Clique \\ Filtros};
    
    \node[box, fill=orange!10, right=1.0cm of algoritmia] (api) {Capa REST \\ \texttt{api\_json/} \\ \texttt{server.rs} \\
    HTTP/JSON};
    
    \draw[arrow] (ingesta) -- (algoritmia);
    \draw[arrow] (algoritmia) -- (api);
    
    \end{tikzpicture}
    \\[0.2cm]
    \textbf{Figura 1:} Pipeline de procesamiento End-to-End del sistema.
\end{center}

\subsubsection{Capa de Ingesta (src/excel/)}
Responsable de la lectura de archivos Excel heterogéneos. Implementación real:
\begin{itemize}
    \item \textbf{io.rs:} Lectura de archivos .xlsx mediante crate \texttt{calamine}, parseo de hojas específicas (``M\_ALUMNOS'', ``Asignaturas'', ``Malla\_\%'')
    \item \textbf{mapeo\_builder.rs:} Construcción del ``Mapeo Maestro'' que resuelve conflictos de nombres entre periodos. Patrón Builder:
    \begin{lstlisting}[language=Rust]
MapeoBuilder::new()
    .with_legacy_file(path_antiguo)
    .with_current_file(path_actual)
    .build()
    \end{lstlisting}
    \item \textbf{malla.rs:} Parsing de malla curricular, construcción de grafo de prerequisitos representado como \texttt{HashMap<String, Vec<String>>}
    \item \textbf{porcentajes.rs:} Lectura de porcentajes de aprobación por ramo, normalización de códigos
    \item \textbf{oferta.rs:} Parseo de oferta académica, extracción de horarios mediante regex \texttt{HORARIO\_REGEX} que captura formato ``DIA HH:MM-HH:MM''
    \item \textbf{cache.rs:} Capa de caché opcional para evitar reparseo de archivos grandes (no implementada en producción actual)
\end{itemize}

\subsubsection{Capa de Algoritmia (src/algorithm/)}
Núcleo del sistema. Implementación real por módulo:
\begin{itemize}
    \item \textbf{ruta.rs:} Orquestador del pipeline de 4 fases (ver Capítulo 3, sección 3.1.1)
    \begin{itemize}
        \item Funciones principales: \texttt{ejecutar\_ruta\_critica\_with\_params}, \texttt{cargar\_equivalencias}, \texttt{aplicar\_equivalencias}, \texttt{filtrar\_sections\_por\_prerequisitos}
        \item Validación de LEY FUNDAMENTAL (líneas 320-380): garantiza ≥1 solución si hay cursos disponibles
    \end{itemize}
    \item \textbf{pert.rs:} Análisis de ruta crítica mediante algoritmo PERT
    \begin{itemize}
        \item Función: \texttt{build\_and\_run\_pert(malla, porcentajes)}
        \item Cálculo de ES/EF/LS/LF y holgura mediante forward/backward pass
        \item Output: \texttt{Vec<RamoDisponible>} con campos \texttt{critico}, \texttt{holgura}, \texttt{numb\_correlativo}
    \end{itemize}
    \item \textbf{clique.rs:} Motor de búsqueda de horarios (algoritmo greedy multi-seed, ver Capítulo 3, sección 3.1.3)
    \begin{itemize}
        \item Funciones: \texttt{get\_clique\_max\_pond\_with\_prefs}, \texttt{compute\_priority}, \texttt{sections\_conflict}
        \item Matriz de adyacencia: \texttt{Vec<Vec<bool>>} donde \texttt{adj[i][j] = !sections\_conflict(i, j)}
        \item Límite de carga: constante \texttt{MAX\_COURSES = 6}
    \end{itemize}
    \item \textbf{conflict.rs:} Detección de solapamientos horarios
    \begin{itemize}
        \item Función: \texttt{parse\_horario(str) -> Vec<(i32, i32, i32)>} (día, inicio\_min, fin\_min)
        \item Normalización: ``LU 08:30-10:00'' → (0, 510, 600) donde 510 = 8*60 + 30
        \item Check de solapamiento: \texttt{max(inicio\_A, inicio\_B) < min(fin\_A, fin\_B)}
    \end{itemize}
    \item \textbf{filters.rs:} Aplicación de filtros estructurados
    \begin{itemize}
        \item Funciones: \texttt{apply\_all\_filters}, \texttt{check\_horarios\_libres}, \texttt{check\_ventana\_descanso}, \texttt{check\_profesor\_preference}
        \item Input: \texttt{UserFilters} (struct con campos opcionales)
    \end{itemize}
    \item \textbf{extract.rs y extract\_optimizado.rs:} Conversión de soluciones a formato JSON para API
\end{itemize}

\subsubsection{Capa REST (src/api\_json/ y src/server.rs)}
Exposición de funcionalidad mediante HTTP:
\begin{itemize}
    \item \textbf{server.rs:} Servidor HTTP con framework Actix-Web, configuración de CORS, rutas registradas en \texttt{fn config()}
    \item \textbf{api\_json/handlers/:} Controladores REST que llaman a \texttt{ejecutar\_ruta\_critica\_with\_params}
    \item Endpoints principales:
    \begin{itemize}
        \item \texttt{POST /solve}: recibe JSON con \texttt{ramos\_pasados} y \texttt{user\_filters}, retorna \texttt{Vec<Solucion>}
        \item \texttt{GET /docs}: UI de Swagger con especificación OpenAPI
    \end{itemize}
\end{itemize}

\begin{center}
    \begin{tikzpicture}[
      node distance=1.0cm,
      box/.style={rectangle, draw, align=center, rounded corners, minimum width=3.5cm, minimum height=0.8cm, fill=gray!10},
      arrow/.style={->, thick},
      every node/.style={font=\footnotesize}
    ]
    
    \node[box, fill=blue!15] (ingesta) {Excel + $\Phi(s)$};
    
    \node[box, fill=green!15, right=of ingesta] (prer)
    {Filtrado Prerreq.};
    
    \node[box, fill=green!10, right=of prer] (filtros)
    {Filtros Usuario};
    
    \node[box, fill=yellow!15, below=of ingesta] (greedy)
    {Motor Greedy};
    
    \node[box, fill=orange!15, right=of greedy] (json)
    {JSON Output};
    
    \draw[arrow] (ingesta) -- (prer);
    \draw[arrow] (prer) -- (filtros);
    \draw[arrow] (filtros.south) -- ++(0,-0.5) -| (greedy.north);
    \draw[arrow] (greedy) -- (json);
    
    \end{tikzpicture}
    \\[0.2cm]
    \textbf{Figura 3:} Diagrama de flujo simplificado del proceso.
\end{center}

\subsubsection{1. Mapeo y normalización}
\subsection{Modelo de datos (src/models/mod.rs)}

Estructuras principales definidas en \texttt{src/models/mod.rs} líneas 1-150:

\begin{lstlisting}[language=Rust]
// Estructura de una seccion de curso
pub struct Seccion {
    pub codigo: String,         // Ej: "CIG1003"
    pub nombre: String,          // Ej: "Introduccion a la Ingenieria"
    pub seccion: String,         // Ej: "01", "02"
    pub horario: String,         // Ej: "LU 08:30-10:00, MI 14:30-16:00"
    pub profesor: String,
    pub codigo_box: String,      // Codigo sin seccion para agrupar labs
}

// Estructura de un ramo disponible con metadatos PERT
pub struct RamoDisponible {
    pub id: String,
    pub nombre: String,
    pub codigo: String,
    pub holgura: i32,           // 0-10 segun PERT
    pub numb_correlativo: i32,  // Posicion en malla curricular
    pub critico: bool,          // true si holgura == 0
    pub requisitos_ids: Vec<String>,
    pub dificultad: Option<f64>,
    pub electivo: bool,
}

// Filtros opcionales del usuario
pub struct UserFilters {
    pub dias_horarios_libres: Option<Vec<DiaHorariosLibres>>,
    pub ventana_entre_actividades: Option<i32>, // minutos
    pub preferencias_profesores: Option<Vec<String>>,
    pub balance_lineas: Option<bool>,
}

// Franja prohibida
pub struct FranjaProhibida {
    pub dia: String,     // "LU", "MA", "MI", "JU", "VI"
    pub inicio: String,  // "08:30"
    pub fin: String,     // "10:00"
}
\end{lstlisting}

Estructuras auxiliares:
\begin{itemize}
    \item \textbf{Solucion:} Wrapper de \texttt{Vec<(Seccion, i32)>} donde el i32 es el score de prioridad individual
    \item \textbf{MapeoMaestro:} \texttt{HashMap<String, String>} para equivalencias (código antiguo → código actual)
    \item \textbf{Malla:} \texttt{HashMap<String, Vec<String>>} para grafo de prerequisitos (código → lista de prerequisitos)
\end{itemize}

\subsection{Normalización y resolución de entidades}

Para resolver el problema de Data Drift entre periodos académicos, se implementó normalización de cadenas en \texttt{excel/mapeo\_builder.rs}:

\begin{lstlisting}[language=Rust]
fn normalize(s: &str) -> String {
    s.to_lowercase()
     .trim()
     .chars()
     .map(|c| match c {
         'á' => 'a', 'é' => 'e', 'í' => 'i', 'ó' => 'o', 'ú' => 'u',
         _ => c,
     })
     .collect()
}
\end{lstlisting}

La función transforma nombres de entrada a forma canónica, permitiendo identificar que ``Inglés General II'' (2024) es equivalente a ``INGLES GENERAL 2'' (2025).

\subsection{Detección de conflictos horarios (src/algorithm/conflict.rs)}

Implementación real de normalización horaria y verificación de solapamiento:

\begin{lstlisting}[language=Rust]
// Parsea "LU 08:30-10:00, MI 14:30-16:00" -> Vec<(dia, inicio_min, fin_min)>
pub fn parse_horario(horario: &str) -> Vec<(i32, i32, i32)> {
    let regex = Regex::new(r"([A-Z]{2})\s+(\d{2}:\d{2})-(\d{2}:\d{2})")
        .unwrap();
    
    regex.captures_iter(horario)
        .map(|cap| {
            let dia = match &cap[1] {
                "LU" => 0, "MA" => 1, "MI" => 2, "JU" => 3, "VI" => 4,
                _ => -1,
            };
            let inicio_min = time_to_minutes(&cap[2]); // "08:30" -> 510
            let fin_min = time_to_minutes(&cap[3]);
            (dia, inicio_min, fin_min)
        })
        .collect()
}

// Verifica solapamiento entre dos secciones
pub fn sections_conflict(sec_a: &Seccion, sec_b: &Seccion) -> bool {
    let bloques_a = parse_horario(&sec_a.horario);
    let bloques_b = parse_horario(&sec_b.horario);
    
    for (dia_a, inicio_a, fin_a) in &bloques_a {
        for (dia_b, inicio_b, fin_b) in &bloques_b {
            if dia_a == dia_b {
                // Overlap check: max(inicio_A, inicio_B) < min(fin_A, fin_B)
                if inicio_a.max(inicio_b) < fin_a.min(fin_b) {
                    return true; // Hay conflicto
                }
            }
        }
    }
    false
}
\end{lstlisting}

Complejidad: $O(1)$ por par de secciones (número de bloques horarios es constante, típicamente 2-4 por sección).

\subsection{Sistema de tests y validación}

El directorio \texttt{tests/} implementa 15+ tests de integración que validan:

\begin{itemize}
    \item \textbf{test\_equivalences.rs:} Verifica mapeo correcto de códigos antiguos a actuales
    \item \textbf{test\_prerequisite\_filtering.rs:} Valida exclusión de cursos sin prerequisitos cumplidos
    \item \textbf{test\_ley\_fundamental.rs:} Garantiza ≥1 solución si hay cursos disponibles (LEY FUNDAMENTAL)
    \item \textbf{test\_conflict\_and\_name\_match.rs:} Verifica detección de conflictos horarios
    \item \textbf{test\_solution\_section\_diversity.rs:} Valida diversidad de soluciones generadas
    \item \textbf{test\_malla2020\_full.rs:} Test end-to-end con datos reales de malla 2020
\end{itemize}

Ejecución de tests: \texttt{cargo test --release}

\subsection{Despliegue y operación}

Compilación y ejecución del servidor:
\begin{lstlisting}[language=bash]
$ cd quickshift
$ cargo build --release
$ ./target/release/quickshift
# Servidor escucha en http://0.0.0.0:8080
# Documentacion Swagger disponible en /docs
\end{lstlisting}

Configuración mediante variables de entorno:
\begin{itemize}
    \item \texttt{RUST\_LOG=debug}: logging detallado
    \item \texttt{PORT=3000}: cambiar puerto por defecto
    \item \texttt{DATA\_PATH=/ruta/archivos}: directorio de archivos Excel
\end{itemize}

